/**
 * Gravitee.io Portal Rest API
 * API dedicated to the devportal part of Gravitee
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@graviteesource.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { Api } from '../model/api';
import { ApiMetrics } from '../model/apiMetrics';
import { ApisResponse } from '../model/apisResponse';
import { ApplicationsResponse } from '../model/applicationsResponse';
import { ErrorResponse } from '../model/errorResponse';
import { FilterApiQuery } from '../model/filterApiQuery';
import { LinksResponse } from '../model/linksResponse';
import { Page } from '../model/page';
import { PagesResponse } from '../model/pagesResponse';
import { PlansResponse } from '../model/plansResponse';
import { Rating } from '../model/rating';
import { RatingAnswerInput } from '../model/ratingAnswerInput';
import { RatingInput } from '../model/ratingInput';
import { RatingsResponse } from '../model/ratingsResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


export interface CreateApiRatingRequestParams {
    apiId: string;
    RatingInput?: RatingInput;
}

export interface CreateApiRatingAnswerRequestParams {
    apiId: string;
    ratingId: string;
    RatingAnswerInput?: RatingAnswerInput;
}

export interface DeleteApiRatingRequestParams {
    apiId: string;
    ratingId: string;
}

export interface DeleteApiRatingAnswerRequestParams {
    apiId: string;
    ratingId: string;
    answerId: string;
}

export interface GetApiByApiIdRequestParams {
    apiId: string;
    include?: Array<'pages' | 'plans'>;
}

export interface GetApiLinksRequestParams {
    apiId: string;
}

export interface GetApiMediaRequestParams {
    apiId: string;
    mediaHash: string;
}

export interface GetApiMetricsByApiIdRequestParams {
    apiId: string;
}

export interface GetApiPlansByApiIdRequestParams {
    apiId: string;
    page?: number;
    size?: number;
}

export interface GetApiRatingsByApiIdRequestParams {
    apiId: string;
    page?: number;
    size?: number;
    mine?: boolean;
    order?: string;
}

export interface GetApisRequestParams {
    page?: number;
    size?: number;
    context_path?: string;
    label?: string;
    version?: string;
    name?: string;
    category?: string;
    filter?: FilterApiQuery;
    _filter?: FilterApiQuery;
    promoted?: boolean;
}

export interface GetPageByApiIdAndPageIdRequestParams {
    apiId: string;
    pageId: string;
    include?: Array<'content'>;
}

export interface GetPageContentByApiIdAndPageIdRequestParams {
    apiId: string;
    pageId: string;
}

export interface GetPagesByApiIdRequestParams {
    apiId: string;
    page?: number;
    size?: number;
    homepage?: boolean;
    parent?: string;
}

export interface GetPictureByApiIdRequestParams {
    apiId: string;
}

export interface GetSubscriberApplicationsByApiIdRequestParams {
    apiId: string;
    page?: number;
    size?: number;
    statuses?: Array<'ACCEPTED' | 'CLOSED' | 'PAUSED' | 'PENDING' | 'REJECTED'>;
}

export interface SearchApisRequestParams {
    q: string;
    page?: number;
    size?: number;
}

export interface UpdateApiRatingRequestParams {
    apiId: string;
    ratingId: string;
    RatingInput?: RatingInput;
}


@Injectable({
  providedIn: 'root'
})
export class ApiService {

    protected basePath = 'http://localhost:8083/portal/environments/DEFAULT';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Create a rating for an API
     * Create a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to create a rating. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApiRating(requestParameters: CreateApiRatingRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Rating>;
    public createApiRating(requestParameters: CreateApiRatingRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rating>>;
    public createApiRating(requestParameters: CreateApiRatingRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rating>>;
    public createApiRating(requestParameters: CreateApiRatingRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling createApiRating.');
        }
        const RatingInput = requestParameters.RatingInput;

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (CookieAuth) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Rating>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,
            RatingInput,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create an answer to rating
     * Create an answer to rating of API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[CREATE] permission to create an answer. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Rating>;
    public createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rating>>;
    public createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rating>>;
    public createApiRatingAnswer(requestParameters: CreateApiRatingAnswerRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling createApiRatingAnswer.');
        }
        const ratingId = requestParameters.ratingId;
        if (ratingId === null || ratingId === undefined) {
            throw new Error('Required parameter ratingId was null or undefined when calling createApiRatingAnswer.');
        }
        const RatingAnswerInput = requestParameters.RatingAnswerInput;

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (CookieAuth) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Rating>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings/${encodeURIComponent(String(ratingId))}/answers`,
            RatingAnswerInput,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a rating for an API
     * Delete a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[DELETE] permission to delete a rating. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApiRating(requestParameters: DeleteApiRatingRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteApiRating(requestParameters: DeleteApiRatingRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteApiRating(requestParameters: DeleteApiRatingRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteApiRating(requestParameters: DeleteApiRatingRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling deleteApiRating.');
        }
        const ratingId = requestParameters.ratingId;
        if (ratingId === null || ratingId === undefined) {
            throw new Error('Required parameter ratingId was null or undefined when calling deleteApiRating.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (CookieAuth) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings/${encodeURIComponent(String(ratingId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an answer rating for an API
     * Delete an answer rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING_ANSWER[DELETE] permission to delete a rating. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteApiRatingAnswer(requestParameters: DeleteApiRatingAnswerRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling deleteApiRatingAnswer.');
        }
        const ratingId = requestParameters.ratingId;
        if (ratingId === null || ratingId === undefined) {
            throw new Error('Required parameter ratingId was null or undefined when calling deleteApiRatingAnswer.');
        }
        const answerId = requestParameters.answerId;
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling deleteApiRatingAnswer.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (CookieAuth) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings/${encodeURIComponent(String(ratingId))}/answers/${encodeURIComponent(String(answerId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the API definition
     * Get the detail of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Api>;
    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Api>>;
    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Api>>;
    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiByApiId.');
        }
        const include = requestParameters.include;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (include) {
            include.forEach((element) => {
                queryParameters = queryParameters.append('include', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Api>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the API links from Aside SYSTEM_FOLDER.
     * Get all the links (internal and external) to be displayed in the detail of the API. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiLinks(requestParameters: GetApiLinksRequestParams, observe?: 'body', reportProgress?: boolean): Observable<LinksResponse>;
    public getApiLinks(requestParameters: GetApiLinksRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LinksResponse>>;
    public getApiLinks(requestParameters: GetApiLinksRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LinksResponse>>;
    public getApiLinks(requestParameters: GetApiLinksRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiLinks.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<LinksResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/links`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the api media.
     * Get api media. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiMedia(requestParameters: GetApiMediaRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getApiMedia(requestParameters: GetApiMediaRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getApiMedia(requestParameters: GetApiMediaRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getApiMedia(requestParameters: GetApiMediaRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiMedia.');
        }
        const mediaHash = requestParameters.mediaHash;
        if (mediaHash === null || mediaHash === undefined) {
            throw new Error('Required parameter mediaHash was null or undefined when calling getApiMedia.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'image/_*',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/media/${encodeURIComponent(String(mediaHash))}`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get API metrics
     * Get some metrics about an API :   * number of subscribers   * number of hits during the last 7 days   * health ratio over the last week  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiMetricsByApiId(requestParameters: GetApiMetricsByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApiMetrics>;
    public getApiMetricsByApiId(requestParameters: GetApiMetricsByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApiMetrics>>;
    public getApiMetricsByApiId(requestParameters: GetApiMetricsByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApiMetrics>>;
    public getApiMetricsByApiId(requestParameters: GetApiMetricsByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiMetricsByApiId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<ApiMetrics>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/metrics`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List plans for an API
     * List plans for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PlansResponse>;
    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlansResponse>>;
    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlansResponse>>;
    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiPlansByApiId.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<PlansResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/plans`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List ratings for an API
     * List ratings for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<RatingsResponse>;
    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RatingsResponse>>;
    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RatingsResponse>>;
    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getApiRatingsByApiId.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;
        const mine = requestParameters.mine;
        const order = requestParameters.order;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (mine !== undefined && mine !== null) {
            queryParameters = queryParameters.set('mine', <any>mine);
        }
        if (order !== undefined && order !== null) {
            queryParameters = queryParameters.set('order', <any>order);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<RatingsResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List APIs
     * List public APIs for anonymous requests. List all the APIs the current user is allowed to category for authenticated requests.  The list can be filtered according to query parameters.  By default the list is sorted by alphabetic order. If a **cat** query param is sent, a specific sorting can be applied. Please refer to **cat** description for detail. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getApis(requestParameters: GetApisRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApisResponse>;
    public getApis(requestParameters: GetApisRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApisResponse>>;
    public getApis(requestParameters: GetApisRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApisResponse>>;
    public getApis(requestParameters: GetApisRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const page = requestParameters.page;
        const size = requestParameters.size;
        const context_path = requestParameters.context_path;
        const label = requestParameters.label;
        const version = requestParameters.version;
        const name = requestParameters.name;
        const category = requestParameters.category;
        const filter = requestParameters.filter;
        const _filter = requestParameters._filter;
        const promoted = requestParameters.promoted;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (context_path !== undefined && context_path !== null) {
            queryParameters = queryParameters.set('context-path', <any>context_path);
        }
        if (label !== undefined && label !== null) {
            queryParameters = queryParameters.set('label', <any>label);
        }
        if (version !== undefined && version !== null) {
            queryParameters = queryParameters.set('version', <any>version);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (_filter !== undefined && _filter !== null) {
            queryParameters = queryParameters.set('-filter', <any>_filter);
        }
        if (promoted !== undefined && promoted !== null) {
            queryParameters = queryParameters.set('promoted', <any>promoted);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<ApisResponse>(`${this.configuration.basePath}/apis`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an API page
     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Page>;
    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;
    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;
    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getPageByApiIdAndPageId.');
        }
        const pageId = requestParameters.pageId;
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling getPageByApiIdAndPageId.');
        }
        const include = requestParameters.include;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (include) {
            include.forEach((element) => {
                queryParameters = queryParameters.append('include', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Page>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the content of an API page.
     * Get the content of a specific API documentation page.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPageContentByApiIdAndPageId(requestParameters: GetPageContentByApiIdAndPageIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getPageContentByApiIdAndPageId(requestParameters: GetPageContentByApiIdAndPageIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getPageContentByApiIdAndPageId(requestParameters: GetPageContentByApiIdAndPageIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getPageContentByApiIdAndPageId(requestParameters: GetPageContentByApiIdAndPageIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getPageContentByApiIdAndPageId.');
        }
        const pageId = requestParameters.pageId;
        if (pageId === null || pageId === undefined) {
            throw new Error('Required parameter pageId was null or undefined when calling getPageContentByApiIdAndPageId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<string>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}/content`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List API pages
     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;
    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;
    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;
    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getPagesByApiId.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;
        const homepage = requestParameters.homepage;
        const parent = requestParameters.parent;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (homepage !== undefined && homepage !== null) {
            queryParameters = queryParameters.set('homepage', <any>homepage);
        }
        if (parent !== undefined && parent !== null) {
            queryParameters = queryParameters.set('parent', <any>parent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the API\&#39;s picture
     * Get the API\&#39;s picture.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getPictureByApiId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'image/_*',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/picture`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List applications that subscribred to an API
     * If the current user is the owner of the API, all connected applications will be returned. Filtered by status. Ordered by number of hits. Else only applications that current is allowed to access will.  This API has to be accessible by the current user, otherwise a 404 will be returned. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubscriberApplicationsByApiId(requestParameters: GetSubscriberApplicationsByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApplicationsResponse>;
    public getSubscriberApplicationsByApiId(requestParameters: GetSubscriberApplicationsByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationsResponse>>;
    public getSubscriberApplicationsByApiId(requestParameters: GetSubscriberApplicationsByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationsResponse>>;
    public getSubscriberApplicationsByApiId(requestParameters: GetSubscriberApplicationsByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling getSubscriberApplicationsByApiId.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;
        const statuses = requestParameters.statuses;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (statuses) {
            statuses.forEach((element) => {
                queryParameters = queryParameters.append('statuses', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<ApplicationsResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/subscribers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search APIs with a query
     * Same as &#x60;/apis&#x60; but with a search query as a parameter. Search for API using the search engine. Supports pagination. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchApis(requestParameters: SearchApisRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApisResponse>;
    public searchApis(requestParameters: SearchApisRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApisResponse>>;
    public searchApis(requestParameters: SearchApisRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApisResponse>>;
    public searchApis(requestParameters: SearchApisRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const q = requestParameters.q;
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchApis.');
        }
        const page = requestParameters.page;
        const size = requestParameters.size;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (q !== undefined && q !== null) {
            queryParameters = queryParameters.set('q', <any>q);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<ApisResponse>(`${this.configuration.basePath}/apis/_search`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a rating for an API
     * Update a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to update a rating. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateApiRating(requestParameters: UpdateApiRatingRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Rating>;
    public updateApiRating(requestParameters: UpdateApiRatingRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rating>>;
    public updateApiRating(requestParameters: UpdateApiRatingRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rating>>;
    public updateApiRating(requestParameters: UpdateApiRatingRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        const apiId = requestParameters.apiId;
        if (apiId === null || apiId === undefined) {
            throw new Error('Required parameter apiId was null or undefined when calling updateApiRating.');
        }
        const ratingId = requestParameters.ratingId;
        if (ratingId === null || ratingId === undefined) {
            throw new Error('Required parameter ratingId was null or undefined when calling updateApiRating.');
        }
        const RatingInput = requestParameters.RatingInput;

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        // authentication (CookieAuth) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Rating>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings/${encodeURIComponent(String(ratingId))}`,
            RatingInput,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
