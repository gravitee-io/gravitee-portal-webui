{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://@gravitee/ng-portal-webclient/encoder.ts","ng://@gravitee/ng-portal-webclient/model/plan.ts","ng://@gravitee/ng-portal-webclient/variables.ts","ng://@gravitee/ng-portal-webclient/configuration.ts","ng://@gravitee/ng-portal-webclient/api/analytics.service.ts","ng://@gravitee/ng-portal-webclient/api/api.service.ts","ng://@gravitee/ng-portal-webclient/api/applications.service.ts","ng://@gravitee/ng-portal-webclient/api/authentication.service.ts","ng://@gravitee/ng-portal-webclient/api/documentation.service.ts","ng://@gravitee/ng-portal-webclient/api/portal.service.ts","ng://@gravitee/ng-portal-webclient/api/subscription.service.ts","ng://@gravitee/ng-portal-webclient/api/user.service.ts","ng://@gravitee/ng-portal-webclient/api/users.service.ts","ng://@gravitee/ng-portal-webclient/api/api.ts","ng://@gravitee/ng-portal-webclient/model/page.ts","ng://@gravitee/ng-portal-webclient/model/subscription.ts","ng://@gravitee/ng-portal-webclient/model/token.ts","ng://@gravitee/ng-portal-webclient/api.module.ts","ng://@gravitee/ng-portal-webclient/model/categoryApiQuery.ts","ng://@gravitee/ng-portal-webclient/model/httpMethod.ts","ng://@gravitee/ng-portal-webclient/model/identityProviderType.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Plan","CustomHttpParameterCodec","prototype","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","Configuration","configurationParameters","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","selectHeaderContentType","contentTypes","_this","type","find","x","isJsonMime","undefined","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","AnalyticsService","httpClient","configuration","defaultHeaders","HttpHeaders","exportApplicationLogsByApplicationId","requestParameters","observe","reportProgress","applicationId","Error","page","size","from","to","query","field","order","queryParameters","HttpParams","set","headers","btoa","httpHeaderAcceptSelected","post","String","params","getApplicationAnalytics","interval","range","aggs","get","getApplicationLogByApplicationIdAndLogId","logId","timestamp","getApplicationLogs","HttpClient","Optional","Inject","args","Injectable","providedIn","tslib_1.__param","ApiService","createApiRatingForApi","apiId","RatingInput","httpContentTypeSelected","getApiByApiId","include","forEach","element","append","getApiPlansByApiId","getApiRatingsByApiId","getApis","context_path","label","version","name","view","cat","getPageByApiIdAndPageId","pageId","getPagesByApiId","homepage","parent","getPictureByApiId","responseType","ApplicationsService","createApplication","ApplicationInput","createApplicationMember","MemberInput","createApplicationNotification","GenericNotificationConfig","deleteApplicationByApplicationId","delete","deleteApplicationMember","memberId","deleteApplicationNotificationByNotificationId","notificationId","getApplicationByApplicationId","getApplicationMemberByApplicationIdAndMemberId","getApplicationPictureByApplicationId","getApplications","getMembersByApplicationId","getNotificationsByApplicationId","renewApplicationSecret","transferMemberOwnership","TransferOwnershipInput","updateApplicationByApplicationId","Application","put","updateApplicationMemberByApplicationIdAndMemberId","updateGenericApplicationNotification","updatePortalApplicationNotification","PortalNotificationConfig","AuthenticationService","exchangeAuthorizationCode","identity","PayloadInput","login","Authorization","logout","tokenExchange","token","DocumentationService","getPageByPageId","getPages","PortalService","createTicket","TicketInput","getPictureByViewId","viewId","getPortalConfiguration","getPortalIdentityProviders","getPortalInformation","getViewByViewId","getViews","SubscriptionService","closeSubscription","subscriptionId","createSubscription","SubscriptionInput","getSubscriptionBuySubscriptionId","getSubscriptions","renewKeySubscription","request_body","revokeKeySubscription","keyId","UserService","deleteAllCurrentUserNotifications","deleteCurrentUserNotificationByNotificationId","getCurrentUser","getCurrentUserAvatar","getCurrentUserNotifications","updateCurrentUser","User","UsersService","finalizeUserRegistration","FinalizeRegistrationInput","getUsers","registerNewUser","RegisterUserInput","APIS","Page","TypeEnum","SWAGGER","MARKDOWN","FOLDER","ROOT","SecurityEnum","APIKEY","KEYLESS","JWT","OAUTH2","ValidationEnum","AUTO","MANUAL","Subscription","StatusEnum","PENDING","ACCEPTED","REJECTED","Token","TokenTypeEnum","BEARER","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","ApiModule_1","providers","provide","useFactory","SkipSelf","NgModule","imports","declarations","exports","csv","tsv","ssv","pipes","FEATURED","MINE","STARRED","TRENDINGS","CONNECT","DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT","TRACE","OTHER","GOOGLE","GITHUB","GRAVITEEIOAM","OIDC"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Plan { \n    /**\n     * Unique identifier of a plan.\n     */\n    id: string;\n    /**\n     * Name of the plan.\n     */\n    name: string;\n    /**\n     * Security used with this plan.\n     */\n    security: Plan.SecurityEnum;\n    /**\n     * Description of the plan.\n     */\n    description: string;\n    /**\n     * List of additionnal terms to describe the plan.\n     */\n    characteristics?: Array<string>;\n    /**\n     * Type of validation for subscription requests.\n     */\n    validation: Plan.ValidationEnum;\n    /**\n     * Priority order\n     */\n    order: number;\n    /**\n     * True if at least one application linked to the current user has subscribed to this plan.\n     */\n    subscribed?: boolean;\n    /**\n     * True if a comment is required when a subscription is created.\n     */\n    comment_required: boolean;\n    /**\n     * Content of the message sent to a user creating a subscription.\n     */\n    comment_question?: string;\n}\nexport namespace Plan {\n    export type SecurityEnum = 'API_KEY' | 'KEY_LESS' | 'JWT' | 'OAUTH2';\n    export const SecurityEnum = {\n        APIKEY: 'API_KEY' as SecurityEnum,\n        KEYLESS: 'KEY_LESS' as SecurityEnum,\n        JWT: 'JWT' as SecurityEnum,\n        OAUTH2: 'OAUTH2' as SecurityEnum\n    };\n    export type ValidationEnum = 'AUTO' | 'MANUAL';\n    export const ValidationEnum = {\n        AUTO: 'AUTO' as ValidationEnum,\n        MANUAL: 'MANUAL' as ValidationEnum\n    };\n}\n\n\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DateHistoAnalytics, GroupByAnalytics, CountAnalytics } from '../model/models';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Log } from '../model/log';\nimport { LogsResponse } from '../model/logsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                       from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface ExportApplicationLogsByApplicationIdRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    query?: string;\n    field?: string;\n    order?: 'ASC' | 'DESC';\n}\n\nexport interface GetApplicationAnalyticsRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    interval?: number;\n    query?: string;\n    field?: string;\n    type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT';\n    range?: string;\n    aggs?: string;\n    order?: string;\n}\n\nexport interface GetApplicationLogByApplicationIdAndLogIdRequestParams {\n    applicationId: string;\n    logId: string;\n    timestamp?: number;\n}\n\nexport interface GetApplicationLogsRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    query?: string;\n    field?: string;\n    order?: 'ASC' | 'DESC';\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnalyticsService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Export application logs as CSV\n     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<string>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationLogsByApplicationId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'text/plain',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<string>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/_export`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application analytics\n     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationAnalytics.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const interval = requestParameters.interval;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const type = requestParameters.type;\n        const range = requestParameters.range;\n        const aggs = requestParameters.aggs;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (interval !== undefined && interval !== null) {\n            queryParameters = queryParameters.set('interval', <any>interval);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (type !== undefined && type !== null) {\n            queryParameters = queryParameters.set('type', <any>type);\n        }\n        if (range !== undefined && range !== null) {\n            queryParameters = queryParameters.set('range', <any>range);\n        }\n        if (aggs !== undefined && aggs !== null) {\n            queryParameters = queryParameters.set('aggs', <any>aggs);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/analytics`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a specific log of an application\n     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Log>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        const logId = requestParameters.logId;\n        if (logId === null || logId === undefined) {\n            throw new Error('Required parameter logId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        const timestamp = requestParameters.timestamp;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (timestamp !== undefined && timestamp !== null) {\n            queryParameters = queryParameters.set('timestamp', <any>timestamp);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Log>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/${encodeURIComponent(String(logId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application logs\n     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<LogsResponse>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogsResponse>>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogsResponse>>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogs.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<LogsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { Api } from '../model/api';\nimport { ApisResponse } from '../model/apisResponse';\nimport { CategoryApiQuery } from '../model/categoryApiQuery';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Page } from '../model/page';\nimport { PagesResponse } from '../model/pagesResponse';\nimport { PlansResponse } from '../model/plansResponse';\nimport { Rating } from '../model/rating';\nimport { RatingInput } from '../model/ratingInput';\nimport { RatingsResponse } from '../model/ratingsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface CreateApiRatingForApiRequestParams {\n    apiId: string;\n    RatingInput?: RatingInput;\n}\n\nexport interface GetApiByApiIdRequestParams {\n    apiId: string;\n    include?: Array<'pages' | 'plans'>;\n}\n\nexport interface GetApiPlansByApiIdRequestParams {\n    apiId: string;\n    page?: number;\n    size?: number;\n}\n\nexport interface GetApiRatingsByApiIdRequestParams {\n    apiId: string;\n    page?: number;\n    size?: number;\n}\n\nexport interface GetApisRequestParams {\n    page?: number;\n    size?: number;\n    context_path?: string;\n    label?: string;\n    version?: string;\n    name?: string;\n    view?: string;\n    cat?: CategoryApiQuery;\n}\n\nexport interface GetPageByApiIdAndPageIdRequestParams {\n    apiId: string;\n    pageId: string;\n}\n\nexport interface GetPagesByApiIdRequestParams {\n    apiId: string;\n    page?: number;\n    size?: number;\n    homepage?: boolean;\n    parent?: string;\n}\n\nexport interface GetPictureByApiIdRequestParams {\n    apiId: string;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ApiService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create a rating for an API\n     * Create a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to create a rating. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApiRatingForApi(requestParameters: CreateApiRatingForApiRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Rating>;\n    public createApiRatingForApi(requestParameters: CreateApiRatingForApiRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rating>>;\n    public createApiRatingForApi(requestParameters: CreateApiRatingForApiRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rating>>;\n    public createApiRatingForApi(requestParameters: CreateApiRatingForApiRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling createApiRatingForApi.');\n        }\n        const RatingInput = requestParameters.RatingInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Rating>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,\n            RatingInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the API definition\n     * Get the detail of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Api>;\n    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Api>>;\n    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Api>>;\n    public getApiByApiId(requestParameters: GetApiByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiByApiId.');\n        }\n        const include = requestParameters.include;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (include) {\n            include.forEach((element) => {\n                queryParameters = queryParameters.append('include', <any>element);\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Api>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List plans for an API\n     * List plans for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PlansResponse>;\n    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlansResponse>>;\n    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlansResponse>>;\n    public getApiPlansByApiId(requestParameters: GetApiPlansByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiPlansByApiId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PlansResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/plans`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List ratings for an API\n     * List ratings for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<RatingsResponse>;\n    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RatingsResponse>>;\n    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RatingsResponse>>;\n    public getApiRatingsByApiId(requestParameters: GetApiRatingsByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiRatingsByApiId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<RatingsResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List APIs\n     * List public APIs for anonymous requests. List all the APIs the current user is allowed to view for authenticated requests.  The list can be filtered according to query parameters.  By default the list is sorted by alphabetic order. If a **cat** query param is sent, a specific sorting can be applied. Please refer to **cat** description for detail. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApis(requestParameters: GetApisRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApisResponse>;\n    public getApis(requestParameters: GetApisRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApisResponse>>;\n    public getApis(requestParameters: GetApisRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApisResponse>>;\n    public getApis(requestParameters: GetApisRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const context_path = requestParameters.context_path;\n        const label = requestParameters.label;\n        const version = requestParameters.version;\n        const name = requestParameters.name;\n        const view = requestParameters.view;\n        const cat = requestParameters.cat;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (context_path !== undefined && context_path !== null) {\n            queryParameters = queryParameters.set('context-path', <any>context_path);\n        }\n        if (label !== undefined && label !== null) {\n            queryParameters = queryParameters.set('label', <any>label);\n        }\n        if (version !== undefined && version !== null) {\n            queryParameters = queryParameters.set('version', <any>version);\n        }\n        if (name !== undefined && name !== null) {\n            queryParameters = queryParameters.set('name', <any>name);\n        }\n        if (view !== undefined && view !== null) {\n            queryParameters = queryParameters.set('view', <any>view);\n        }\n        if (cat !== undefined && cat !== null) {\n            queryParameters = queryParameters.set('cat', <any>cat);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ApisResponse>(`${this.configuration.basePath}/apis`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an API page\n     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n        const pageId = requestParameters.pageId;\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List API pages\n     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPagesByApiId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const homepage = requestParameters.homepage;\n        const parent = requestParameters.parent;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the API\\&#39;s picture\n     * Get the API\\&#39;s picture.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getPictureByApiId(requestParameters: GetPictureByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPictureByApiId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { Application } from '../model/application';\nimport { ApplicationInput } from '../model/applicationInput';\nimport { ApplicationsResponse } from '../model/applicationsResponse';\nimport { DateHistoAnalytics, GroupByAnalytics, CountAnalytics } from '../model/models';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { GenericNotificationConfig } from '../model/genericNotificationConfig';\nimport { Log } from '../model/log';\nimport { LogsResponse } from '../model/logsResponse';\nimport { Member } from '../model/member';\nimport { MemberInput } from '../model/memberInput';\nimport { MembersResponse } from '../model/membersResponse';\nimport { NotificationConfigsResponse } from '../model/notificationConfigsResponse';\nimport { PortalNotificationConfig } from '../model/portalNotificationConfig';\nimport { TransferOwnershipInput } from '../model/transferOwnershipInput';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface CreateApplicationRequestParams {\n    ApplicationInput?: ApplicationInput;\n}\n\nexport interface CreateApplicationMemberRequestParams {\n    applicationId: string;\n    MemberInput?: MemberInput;\n}\n\nexport interface CreateApplicationNotificationRequestParams {\n    applicationId: string;\n    GenericNotificationConfig?: GenericNotificationConfig;\n}\n\nexport interface DeleteApplicationByApplicationIdRequestParams {\n    applicationId: string;\n}\n\nexport interface DeleteApplicationMemberRequestParams {\n    applicationId: string;\n    memberId: string;\n}\n\nexport interface DeleteApplicationNotificationByNotificationIdRequestParams {\n    applicationId: string;\n    notificationId: string;\n}\n\nexport interface ExportApplicationLogsByApplicationIdRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    query?: string;\n    field?: string;\n    order?: 'ASC' | 'DESC';\n}\n\nexport interface GetApplicationAnalyticsRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    interval?: number;\n    query?: string;\n    field?: string;\n    type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT';\n    range?: string;\n    aggs?: string;\n    order?: string;\n}\n\nexport interface GetApplicationByApplicationIdRequestParams {\n    applicationId: string;\n}\n\nexport interface GetApplicationLogByApplicationIdAndLogIdRequestParams {\n    applicationId: string;\n    logId: string;\n    timestamp?: number;\n}\n\nexport interface GetApplicationLogsRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n    from?: number;\n    to?: number;\n    query?: string;\n    field?: string;\n    order?: 'ASC' | 'DESC';\n}\n\nexport interface GetApplicationMemberByApplicationIdAndMemberIdRequestParams {\n    applicationId: string;\n    memberId: string;\n}\n\nexport interface GetApplicationPictureByApplicationIdRequestParams {\n    applicationId: string;\n}\n\nexport interface GetApplicationsRequestParams {\n    page?: number;\n    size?: number;\n}\n\nexport interface GetMembersByApplicationIdRequestParams {\n    applicationId: string;\n    page?: number;\n    size?: number;\n}\n\nexport interface GetNotificationsByApplicationIdRequestParams {\n    applicationId: string;\n}\n\nexport interface RenewApplicationSecretRequestParams {\n    applicationId: string;\n}\n\nexport interface TransferMemberOwnershipRequestParams {\n    applicationId: string;\n    TransferOwnershipInput?: TransferOwnershipInput;\n}\n\nexport interface UpdateApplicationByApplicationIdRequestParams {\n    applicationId: string;\n    Application?: Application;\n}\n\nexport interface UpdateApplicationMemberByApplicationIdAndMemberIdRequestParams {\n    applicationId: string;\n    memberId: string;\n    MemberInput?: MemberInput;\n}\n\nexport interface UpdateGenericApplicationNotificationRequestParams {\n    applicationId: string;\n    notificationId: string;\n    GenericNotificationConfig?: GenericNotificationConfig;\n}\n\nexport interface UpdatePortalApplicationNotificationRequestParams {\n    applicationId: string;\n    PortalNotificationConfig?: PortalNotificationConfig;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ApplicationsService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create an application\n     * Create an application.  User must have MANAGEMENT_APPLICATION[CREATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplication(requestParameters: CreateApplicationRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public createApplication(requestParameters: CreateApplicationRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public createApplication(requestParameters: CreateApplicationRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public createApplication(requestParameters: CreateApplicationRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const ApplicationInput = requestParameters.ApplicationInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Application>(`${this.configuration.basePath}/applications`,\n            ApplicationInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create an application member\n     * Create an application member.  User must have the APPLICATION_MEMBER[CREATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplicationMember(requestParameters: CreateApplicationMemberRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public createApplicationMember(requestParameters: CreateApplicationMemberRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public createApplicationMember(requestParameters: CreateApplicationMemberRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public createApplicationMember(requestParameters: CreateApplicationMemberRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling createApplicationMember.');\n        }\n        const MemberInput = requestParameters.MemberInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members`,\n            MemberInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create notification settings.\n     * Create notification settings.  User must have APPLICATION_NOTIFICATION[READ] permission to create a **portal** notification.  User must have APPLICATION_NOTIFICATION[CREATE] permission to create a **generic** notification.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplicationNotification(requestParameters: CreateApplicationNotificationRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationConfig | GenericNotificationConfig>;\n    public createApplicationNotification(requestParameters: CreateApplicationNotificationRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationConfig | GenericNotificationConfig>>;\n    public createApplicationNotification(requestParameters: CreateApplicationNotificationRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationConfig | GenericNotificationConfig>>;\n    public createApplicationNotification(requestParameters: CreateApplicationNotificationRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling createApplicationNotification.');\n        }\n        const GenericNotificationConfig = requestParameters.GenericNotificationConfig;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<PortalNotificationConfig | GenericNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            GenericNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an application\n     * Delete an application.  User must have the APPLICATION_DEFINITION[DELETE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationByApplicationId(requestParameters: DeleteApplicationByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationByApplicationId(requestParameters: DeleteApplicationByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationByApplicationId(requestParameters: DeleteApplicationByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationByApplicationId(requestParameters: DeleteApplicationByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove an application member\n     * Remove an application member.  User must have the APPLICATION_MEMBER[DELETE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationMember(requestParameters: DeleteApplicationMemberRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationMember(requestParameters: DeleteApplicationMemberRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationMember(requestParameters: DeleteApplicationMemberRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationMember(requestParameters: DeleteApplicationMemberRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationMember.');\n        }\n        const memberId = requestParameters.memberId;\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling deleteApplicationMember.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a notification\n     * Delete a notification.  User must have APPLICATION_NOTIFICATION[DELETE] permission to delete a **generic** notification.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationNotificationByNotificationId(requestParameters: DeleteApplicationNotificationByNotificationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationNotificationByNotificationId(requestParameters: DeleteApplicationNotificationByNotificationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationNotificationByNotificationId(requestParameters: DeleteApplicationNotificationByNotificationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationNotificationByNotificationId(requestParameters: DeleteApplicationNotificationByNotificationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationNotificationByNotificationId.');\n        }\n        const notificationId = requestParameters.notificationId;\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling deleteApplicationNotificationByNotificationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications/${encodeURIComponent(String(notificationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Export application logs as CSV\n     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<string>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;\n    public exportApplicationLogsByApplicationId(requestParameters: ExportApplicationLogsByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationLogsByApplicationId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'text/plain',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<string>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/_export`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application analytics\n     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(requestParameters: GetApplicationAnalyticsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationAnalytics.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const interval = requestParameters.interval;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const type = requestParameters.type;\n        const range = requestParameters.range;\n        const aggs = requestParameters.aggs;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (interval !== undefined && interval !== null) {\n            queryParameters = queryParameters.set('interval', <any>interval);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (type !== undefined && type !== null) {\n            queryParameters = queryParameters.set('type', <any>type);\n        }\n        if (range !== undefined && range !== null) {\n            queryParameters = queryParameters.set('range', <any>range);\n        }\n        if (aggs !== undefined && aggs !== null) {\n            queryParameters = queryParameters.set('aggs', <any>aggs);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/analytics`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an application.\n     * Get an application.  User must have the APPLICATION_DEFINITION[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationByApplicationId(requestParameters: GetApplicationByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public getApplicationByApplicationId(requestParameters: GetApplicationByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public getApplicationByApplicationId(requestParameters: GetApplicationByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public getApplicationByApplicationId(requestParameters: GetApplicationByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a specific log of an application\n     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Log>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(requestParameters: GetApplicationLogByApplicationIdAndLogIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        const logId = requestParameters.logId;\n        if (logId === null || logId === undefined) {\n            throw new Error('Required parameter logId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        const timestamp = requestParameters.timestamp;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (timestamp !== undefined && timestamp !== null) {\n            queryParameters = queryParameters.set('timestamp', <any>timestamp);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Log>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/${encodeURIComponent(String(logId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application logs\n     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<LogsResponse>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogsResponse>>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogsResponse>>;\n    public getApplicationLogs(requestParameters: GetApplicationLogsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogs.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const from = requestParameters.from;\n        const to = requestParameters.to;\n        const query = requestParameters.query;\n        const field = requestParameters.field;\n        const order = requestParameters.order;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<LogsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an application member\n     * Get an application member.  User must have the APPLICATION_MEMBER[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationMemberByApplicationIdAndMemberId(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public getApplicationMemberByApplicationIdAndMemberId(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public getApplicationMemberByApplicationIdAndMemberId(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public getApplicationMemberByApplicationIdAndMemberId(requestParameters: GetApplicationMemberByApplicationIdAndMemberIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');\n        }\n        const memberId = requestParameters.memberId;\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the application\\&#39;s picture\n     * Get the application\\&#39;s picture.  User must have APPLICATION_DEFINITION[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationPictureByApplicationId(requestParameters: GetApplicationPictureByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getApplicationPictureByApplicationId(requestParameters: GetApplicationPictureByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getApplicationPictureByApplicationId(requestParameters: GetApplicationPictureByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getApplicationPictureByApplicationId(requestParameters: GetApplicationPictureByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationPictureByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List all the applications accessible to authenticated user.\n     * List all the applications accessible to authenticated user.  User must have MANAGEMENT_APPLICATION[READ] and PORTAL_APPLICATION[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplications(requestParameters: GetApplicationsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ApplicationsResponse>;\n    public getApplications(requestParameters: GetApplicationsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationsResponse>>;\n    public getApplications(requestParameters: GetApplicationsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationsResponse>>;\n    public getApplications(requestParameters: GetApplicationsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ApplicationsResponse>(`${this.configuration.basePath}/applications`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List application members\n     * List application members.  User must have the APPLICATION_MEMBER[READ] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMembersByApplicationId(requestParameters: GetMembersByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<MembersResponse>;\n    public getMembersByApplicationId(requestParameters: GetMembersByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MembersResponse>>;\n    public getMembersByApplicationId(requestParameters: GetMembersByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MembersResponse>>;\n    public getMembersByApplicationId(requestParameters: GetMembersByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getMembersByApplicationId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<MembersResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get application notifications settings\n     * Get application notifications settings.  User must **at least** have APPLICATION_NOTIFICATION[READ] permission to get **portal** notification settings.  User must **also** have APPLICATION_NOTIFICATION[CREATE | UPDATE | DELETE] permission to get **generic** notification settings.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getNotificationsByApplicationId(requestParameters: GetNotificationsByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<NotificationConfigsResponse>;\n    public getNotificationsByApplicationId(requestParameters: GetNotificationsByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationConfigsResponse>>;\n    public getNotificationsByApplicationId(requestParameters: GetNotificationsByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationConfigsResponse>>;\n    public getNotificationsByApplicationId(requestParameters: GetNotificationsByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getNotificationsByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<NotificationConfigsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Renew the client secret for an OAuth2 application\n     * Renew the client secret for an OAuth2 application.  User must have the APPLICATION_DEFINITION[UPDATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public renewApplicationSecret(requestParameters: RenewApplicationSecretRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public renewApplicationSecret(requestParameters: RenewApplicationSecretRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public renewApplicationSecret(requestParameters: RenewApplicationSecretRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public renewApplicationSecret(requestParameters: RenewApplicationSecretRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling renewApplicationSecret.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/_renew_secret`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Transfer the ownership of the application\n     * Transfer the ownership of the application.  User must have the APPLICATION_MEMBER[UPDATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public transferMemberOwnership(requestParameters: TransferMemberOwnershipRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public transferMemberOwnership(requestParameters: TransferMemberOwnershipRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public transferMemberOwnership(requestParameters: TransferMemberOwnershipRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public transferMemberOwnership(requestParameters: TransferMemberOwnershipRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling transferMemberOwnership.');\n        }\n        const TransferOwnershipInput = requestParameters.TransferOwnershipInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/_transfer_ownership`,\n            TransferOwnershipInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an application.\n     * Update an application.  User must have APPLICATION_DEFINITION[UPDATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateApplicationByApplicationId(requestParameters: UpdateApplicationByApplicationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public updateApplicationByApplicationId(requestParameters: UpdateApplicationByApplicationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public updateApplicationByApplicationId(requestParameters: UpdateApplicationByApplicationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public updateApplicationByApplicationId(requestParameters: UpdateApplicationByApplicationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateApplicationByApplicationId.');\n        }\n        const Application = requestParameters.Application;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            Application,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an application member.\n     * Update an application member.  User must have the APPLICATION_MEMBER[UPDATE] permission.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateApplicationMemberByApplicationIdAndMemberId(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public updateApplicationMemberByApplicationIdAndMemberId(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public updateApplicationMemberByApplicationIdAndMemberId(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public updateApplicationMemberByApplicationIdAndMemberId(requestParameters: UpdateApplicationMemberByApplicationIdAndMemberIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');\n        }\n        const memberId = requestParameters.memberId;\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');\n        }\n        const MemberInput = requestParameters.MemberInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            MemberInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a generic notification for an application.\n     * Update a generic notification for an application.  User must have APPLICATION_NOTIFICATION[UPDATE] permission to update a **generic** notification.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateGenericApplicationNotification(requestParameters: UpdateGenericApplicationNotificationRequestParams, observe?: 'body', reportProgress?: boolean): Observable<GenericNotificationConfig>;\n    public updateGenericApplicationNotification(requestParameters: UpdateGenericApplicationNotificationRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericNotificationConfig>>;\n    public updateGenericApplicationNotification(requestParameters: UpdateGenericApplicationNotificationRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericNotificationConfig>>;\n    public updateGenericApplicationNotification(requestParameters: UpdateGenericApplicationNotificationRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateGenericApplicationNotification.');\n        }\n        const notificationId = requestParameters.notificationId;\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling updateGenericApplicationNotification.');\n        }\n        const GenericNotificationConfig = requestParameters.GenericNotificationConfig;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<GenericNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications/${encodeURIComponent(String(notificationId))}`,\n            GenericNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a portal notification for an application.\n     * Update a portal notification for an application.  User must have APPLICATION_NOTIFICATION[READ] permission to update a **portal** notification.\n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePortalApplicationNotification(requestParameters: UpdatePortalApplicationNotificationRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationConfig>;\n    public updatePortalApplicationNotification(requestParameters: UpdatePortalApplicationNotificationRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationConfig>>;\n    public updatePortalApplicationNotification(requestParameters: UpdatePortalApplicationNotificationRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationConfig>>;\n    public updatePortalApplicationNotification(requestParameters: UpdatePortalApplicationNotificationRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const applicationId = requestParameters.applicationId;\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updatePortalApplicationNotification.');\n        }\n        const PortalNotificationConfig = requestParameters.PortalNotificationConfig;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<PortalNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            PortalNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { PayloadInput } from '../model/payloadInput';\nimport { Token } from '../model/token';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface ExchangeAuthorizationCodeRequestParams {\n    identity: string;\n    PayloadInput?: PayloadInput;\n}\n\nexport interface LoginRequestParams {\n    Authorization: string;\n}\n\nexport interface TokenExchangeRequestParams {\n    identity: string;\n    token: string;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthenticationService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Used to get a gravitee token from an Authorization code (PayloadInput.code). Portal API authenticates the user with the specified IDP ({identity} path param). \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exchangeAuthorizationCode(requestParameters: ExchangeAuthorizationCodeRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public exchangeAuthorizationCode(requestParameters: ExchangeAuthorizationCodeRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public exchangeAuthorizationCode(requestParameters: ExchangeAuthorizationCodeRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public exchangeAuthorizationCode(requestParameters: ExchangeAuthorizationCodeRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const identity = requestParameters.identity;\n        if (identity === null || identity === undefined) {\n            throw new Error('Required parameter identity was null or undefined when calling exchangeAuthorizationCode.');\n        }\n        const PayloadInput = requestParameters.PayloadInput;\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/oauth2/${encodeURIComponent(String(identity))}`,\n            PayloadInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Used to get a Gravitee token. This token is mandatory for all the secured resources of the Portal API. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public login(requestParameters: LoginRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public login(requestParameters: LoginRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public login(requestParameters: LoginRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public login(requestParameters: LoginRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const Authorization = requestParameters.Authorization;\n        if (Authorization === null || Authorization === undefined) {\n            throw new Error('Required parameter Authorization was null or undefined when calling login.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (Authorization !== undefined && Authorization !== null) {\n            headers = headers.set('Authorization', String(Authorization));\n        }\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/login`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * User need to be authenticated to logout. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public logout(observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public logout(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public logout(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public logout(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/auth/logout`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Used to get a gravitee token from a IdentityProvider token. Portal API authenticates the user with the specified IDP ({identity} path param). \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public tokenExchange(requestParameters: TokenExchangeRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public tokenExchange(requestParameters: TokenExchangeRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public tokenExchange(requestParameters: TokenExchangeRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public tokenExchange(requestParameters: TokenExchangeRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const identity = requestParameters.identity;\n        if (identity === null || identity === undefined) {\n            throw new Error('Required parameter identity was null or undefined when calling tokenExchange.');\n        }\n        const token = requestParameters.token;\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling tokenExchange.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (token !== undefined && token !== null) {\n            queryParameters = queryParameters.set('token', <any>token);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/oauth2/${encodeURIComponent(String(identity))}/_exchange`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Page } from '../model/page';\nimport { PagesResponse } from '../model/pagesResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface GetPageByApiIdAndPageIdRequestParams {\n    apiId: string;\n    pageId: string;\n}\n\nexport interface GetPageByPageIdRequestParams {\n    pageId: string;\n}\n\nexport interface GetPagesRequestParams {\n    page?: number;\n    size?: number;\n    homepage?: boolean;\n    parent?: string;\n}\n\nexport interface GetPagesByApiIdRequestParams {\n    apiId: string;\n    page?: number;\n    size?: number;\n    homepage?: boolean;\n    parent?: string;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DocumentationService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Get an API page\n     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByApiIdAndPageId(requestParameters: GetPageByApiIdAndPageIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n        const pageId = requestParameters.pageId;\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a portal page\n     * Get a specific portal documentation page. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByPageId(requestParameters: GetPageByPageIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByPageId(requestParameters: GetPageByPageIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByPageId(requestParameters: GetPageByPageIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByPageId(requestParameters: GetPageByPageIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const pageId = requestParameters.pageId;\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List portal pages\n     * List all portal documentation pages \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPages(requestParameters: GetPagesRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPages(requestParameters: GetPagesRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPages(requestParameters: GetPagesRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPages(requestParameters: GetPagesRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const homepage = requestParameters.homepage;\n        const parent = requestParameters.parent;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List API pages\n     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPagesByApiId(requestParameters: GetPagesByApiIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPagesByApiId.');\n        }\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n        const homepage = requestParameters.homepage;\n        const parent = requestParameters.parent;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ConfigurationIdentitiesResponse } from '../model/configurationIdentitiesResponse';\nimport { ConfigurationResponse } from '../model/configurationResponse';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Info } from '../model/info';\nimport { TicketInput } from '../model/ticketInput';\nimport { View } from '../model/view';\nimport { ViewsResponse } from '../model/viewsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface CreateTicketRequestParams {\n    TicketInput?: TicketInput;\n}\n\nexport interface GetPictureByViewIdRequestParams {\n    viewId: string;\n}\n\nexport interface GetViewByViewIdRequestParams {\n    viewId: string;\n}\n\nexport interface GetViewsRequestParams {\n    page?: number;\n    size?: number;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PortalService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create a ticket.\n     * Create a ticket. This ticket can aim :   * a specific application   * a specific API   * the gravitee portal  User must be authenticated to use this service. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createTicket(requestParameters: CreateTicketRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public createTicket(requestParameters: CreateTicketRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public createTicket(requestParameters: CreateTicketRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public createTicket(requestParameters: CreateTicketRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const TicketInput = requestParameters.TicketInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/tickets`,\n            TicketInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get picture of a View\n     * Get the picture of a view. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPictureByViewId(requestParameters: GetPictureByViewIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getPictureByViewId(requestParameters: GetPictureByViewIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getPictureByViewId(requestParameters: GetPictureByViewIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getPictureByViewId(requestParameters: GetPictureByViewIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const viewId = requestParameters.viewId;\n        if (viewId === null || viewId === undefined) {\n            throw new Error('Required parameter viewId was null or undefined when calling getPictureByViewId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/views/${encodeURIComponent(String(viewId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get portal configuration.\n     * Get all the portal configuration from the platform settings. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalConfiguration(observe?: 'body', reportProgress?: boolean): Observable<ConfigurationResponse>;\n    public getPortalConfiguration(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationResponse>>;\n    public getPortalConfiguration(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationResponse>>;\n    public getPortalConfiguration(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ConfigurationResponse>(`${this.configuration.basePath}/configuration`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the identity provider list.\n     * Get all the identity providers that can used in the portal. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalIdentityProviders(observe?: 'body', reportProgress?: boolean): Observable<ConfigurationIdentitiesResponse>;\n    public getPortalIdentityProviders(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationIdentitiesResponse>>;\n    public getPortalIdentityProviders(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationIdentitiesResponse>>;\n    public getPortalIdentityProviders(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ConfigurationIdentitiesResponse>(`${this.configuration.basePath}/configuration/identities`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get portal information.\n     * Get some information about the portal (version, ...). \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalInformation(observe?: 'body', reportProgress?: boolean): Observable<Info>;\n    public getPortalInformation(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Info>>;\n    public getPortalInformation(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Info>>;\n    public getPortalInformation(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Info>(`${this.configuration.basePath}/info`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a View\n     * Get a specific view. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getViewByViewId(requestParameters: GetViewByViewIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<View>;\n    public getViewByViewId(requestParameters: GetViewByViewIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<View>>;\n    public getViewByViewId(requestParameters: GetViewByViewIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<View>>;\n    public getViewByViewId(requestParameters: GetViewByViewIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const viewId = requestParameters.viewId;\n        if (viewId === null || viewId === undefined) {\n            throw new Error('Required parameter viewId was null or undefined when calling getViewByViewId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<View>(`${this.configuration.basePath}/views/${encodeURIComponent(String(viewId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a View list\n     * Get all views of the platform. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getViews(requestParameters: GetViewsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<ViewsResponse>;\n    public getViews(requestParameters: GetViewsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ViewsResponse>>;\n    public getViews(requestParameters: GetViewsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ViewsResponse>>;\n    public getViews(requestParameters: GetViewsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ViewsResponse>(`${this.configuration.basePath}/views`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Key } from '../model/key';\nimport { Subscription } from '../model/subscription';\nimport { SubscriptionInput } from '../model/subscriptionInput';\nimport { SubscriptionsResponse } from '../model/subscriptionsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface CloseSubscriptionRequestParams {\n    subscriptionId: string;\n}\n\nexport interface CreateSubscriptionRequestParams {\n    SubscriptionInput?: SubscriptionInput;\n}\n\nexport interface GetSubscriptionBuySubscriptionIdRequestParams {\n    subscriptionId: string;\n    include?: Array<'keys'>;\n}\n\nexport interface GetSubscriptionsRequestParams {\n    apiId?: string;\n    applicationId?: string;\n    page?: number;\n    size?: number;\n}\n\nexport interface RenewKeySubscriptionRequestParams {\n    subscriptionId: string;\n    request_body?: Array<string>;\n}\n\nexport interface RevokeKeySubscriptionRequestParams {\n    subscriptionId: string;\n    keyId: string;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SubscriptionService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Close a subscription\n     * Close a subscription.  User must have APPLICATION_SUBSCRIPTION[DELETE] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public closeSubscription(requestParameters: CloseSubscriptionRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public closeSubscription(requestParameters: CloseSubscriptionRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public closeSubscription(requestParameters: CloseSubscriptionRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public closeSubscription(requestParameters: CloseSubscriptionRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const subscriptionId = requestParameters.subscriptionId;\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling closeSubscription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/_close`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create a subscription.\n     * Create a new subscription.  User must have APPLICATION_SUBSCRIPTION[CREATE] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSubscription(requestParameters: CreateSubscriptionRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Subscription>;\n    public createSubscription(requestParameters: CreateSubscriptionRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Subscription>>;\n    public createSubscription(requestParameters: CreateSubscriptionRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Subscription>>;\n    public createSubscription(requestParameters: CreateSubscriptionRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const SubscriptionInput = requestParameters.SubscriptionInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Subscription>(`${this.configuration.basePath}/subscriptions`,\n            SubscriptionInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a subscription.\n     * Get a subscription.  User must have API_SUBSCRIPTION[CREATE] or APPLICATION_SUBSCRIPTION[CREATE] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSubscriptionBuySubscriptionId(requestParameters: GetSubscriptionBuySubscriptionIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Subscription>;\n    public getSubscriptionBuySubscriptionId(requestParameters: GetSubscriptionBuySubscriptionIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Subscription>>;\n    public getSubscriptionBuySubscriptionId(requestParameters: GetSubscriptionBuySubscriptionIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Subscription>>;\n    public getSubscriptionBuySubscriptionId(requestParameters: GetSubscriptionBuySubscriptionIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const subscriptionId = requestParameters.subscriptionId;\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling getSubscriptionBuySubscriptionId.');\n        }\n        const include = requestParameters.include;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (include) {\n            include.forEach((element) => {\n                queryParameters = queryParameters.append('include', <any>element);\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Subscription>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List all subscriptions, filtered by api and/or by application. At least an api or an application must be provided.  User must have the APPLICATION_SUBSCRIPTION[READ] permission to list subscription with application query param.\\\\ User must have the API_SUBSCRIPTION[READ] permission to list subscription with api query param. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSubscriptions(requestParameters: GetSubscriptionsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<SubscriptionsResponse>;\n    public getSubscriptions(requestParameters: GetSubscriptionsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubscriptionsResponse>>;\n    public getSubscriptions(requestParameters: GetSubscriptionsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubscriptionsResponse>>;\n    public getSubscriptions(requestParameters: GetSubscriptionsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const apiId = requestParameters.apiId;\n        const applicationId = requestParameters.applicationId;\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (apiId !== undefined && apiId !== null) {\n            queryParameters = queryParameters.set('apiId', <any>apiId);\n        }\n        if (applicationId !== undefined && applicationId !== null) {\n            queryParameters = queryParameters.set('applicationId', <any>applicationId);\n        }\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<SubscriptionsResponse>(`${this.configuration.basePath}/subscriptions`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Renew a key subscription.\n     * Renew a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public renewKeySubscription(requestParameters: RenewKeySubscriptionRequestParams, observe?: 'body', reportProgress?: boolean): Observable<Key>;\n    public renewKeySubscription(requestParameters: RenewKeySubscriptionRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Key>>;\n    public renewKeySubscription(requestParameters: RenewKeySubscriptionRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Key>>;\n    public renewKeySubscription(requestParameters: RenewKeySubscriptionRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const subscriptionId = requestParameters.subscriptionId;\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling renewKeySubscription.');\n        }\n        const request_body = requestParameters.request_body;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Key>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/keys/_renew`,\n            request_body,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Revoke a key subscription.\n     * Revoke a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public revokeKeySubscription(requestParameters: RevokeKeySubscriptionRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public revokeKeySubscription(requestParameters: RevokeKeySubscriptionRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public revokeKeySubscription(requestParameters: RevokeKeySubscriptionRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public revokeKeySubscription(requestParameters: RevokeKeySubscriptionRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const subscriptionId = requestParameters.subscriptionId;\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling revokeKeySubscription.');\n        }\n        const keyId = requestParameters.keyId;\n        if (keyId === null || keyId === undefined) {\n            throw new Error('Required parameter keyId was null or undefined when calling revokeKeySubscription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/keys/${encodeURIComponent(String(keyId))}/_revoke`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { PortalNotificationsResponse } from '../model/portalNotificationsResponse';\nimport { User } from '../model/user';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface DeleteCurrentUserNotificationByNotificationIdRequestParams {\n    notificationId: string;\n}\n\nexport interface GetCurrentUserNotificationsRequestParams {\n    page?: number;\n    size?: number;\n}\n\nexport interface UpdateCurrentUserRequestParams {\n    User?: User;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Delete all notifications of the current user\n     * Delete all notifications of the current user. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAllCurrentUserNotifications(observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteAllCurrentUserNotifications(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteAllCurrentUserNotifications(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteAllCurrentUserNotifications(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/user/notifications`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a specific notification of the current user\n     * Delete a specific notification of the current user. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCurrentUserNotificationByNotificationId(requestParameters: DeleteCurrentUserNotificationByNotificationIdRequestParams, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteCurrentUserNotificationByNotificationId(requestParameters: DeleteCurrentUserNotificationByNotificationIdRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteCurrentUserNotificationByNotificationId(requestParameters: DeleteCurrentUserNotificationByNotificationIdRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteCurrentUserNotificationByNotificationId(requestParameters: DeleteCurrentUserNotificationByNotificationIdRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const notificationId = requestParameters.notificationId;\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling deleteCurrentUserNotificationByNotificationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/user/notifications/${encodeURIComponent(String(notificationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the authenticated user\n     * Get information about the authenticated user. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUser(observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public getCurrentUser(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public getCurrentUser(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public getCurrentUser(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<User>(`${this.configuration.basePath}/user`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve user\\&#39;s avatar\n     * Retrieve user\\&#39;s avatar. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUserAvatar(observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getCurrentUserAvatar(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getCurrentUserAvatar(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getCurrentUserAvatar(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/user/avatar`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve user\\&#39;s notifications\n     * Retrieve current user\\&#39;s notifications. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUserNotifications(requestParameters: GetCurrentUserNotificationsRequestParams, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationsResponse>;\n    public getCurrentUserNotifications(requestParameters: GetCurrentUserNotificationsRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationsResponse>>;\n    public getCurrentUserNotifications(requestParameters: GetCurrentUserNotificationsRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationsResponse>>;\n    public getCurrentUserNotifications(requestParameters: GetCurrentUserNotificationsRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PortalNotificationsResponse>(`${this.configuration.basePath}/user/notifications`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Modify current user information.\n     * Modify current user information.  Only the current user can modify his/her information. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCurrentUser(requestParameters: UpdateCurrentUserRequestParams, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public updateCurrentUser(requestParameters: UpdateCurrentUserRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public updateCurrentUser(requestParameters: UpdateCurrentUserRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public updateCurrentUser(requestParameters: UpdateCurrentUserRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const User = requestParameters.User;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<User>(`${this.configuration.basePath}/user`,\n            User,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { FinalizeRegistrationInput } from '../model/finalizeRegistrationInput';\nimport { RegisterUserInput } from '../model/registerUserInput';\nimport { User } from '../model/user';\nimport { UsersResponse } from '../model/usersResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\nexport interface FinalizeUserRegistrationRequestParams {\n    FinalizeRegistrationInput?: FinalizeRegistrationInput;\n}\n\nexport interface GetUsersRequestParams {\n    page?: number;\n    size?: number;\n}\n\nexport interface RegisterNewUserRequestParams {\n    RegisterUserInput?: RegisterUserInput;\n}\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UsersService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Finalize user registration.\n     * Create a new user for the portal.  User registration must be enabled. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public finalizeUserRegistration(requestParameters: FinalizeUserRegistrationRequestParams, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public finalizeUserRegistration(requestParameters: FinalizeUserRegistrationRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public finalizeUserRegistration(requestParameters: FinalizeUserRegistrationRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public finalizeUserRegistration(requestParameters: FinalizeUserRegistrationRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const FinalizeRegistrationInput = requestParameters.FinalizeRegistrationInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/users/registration/_finalize`,\n            FinalizeRegistrationInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List platform users.\n     * List platform users.  User must have the MANAGEMENT_USERS[READ] permission. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUsers(requestParameters: GetUsersRequestParams, observe?: 'body', reportProgress?: boolean): Observable<UsersResponse>;\n    public getUsers(requestParameters: GetUsersRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsersResponse>>;\n    public getUsers(requestParameters: GetUsersRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsersResponse>>;\n    public getUsers(requestParameters: GetUsersRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const page = requestParameters.page;\n        const size = requestParameters.size;\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<UsersResponse>(`${this.configuration.basePath}/users`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Register a new user.\n     * Register a new user for the portal. As a result, an email is sent with an activation link.  User registration must be enabled.\\\\ A SMTP server must have been configured. \n     * @param requestParameters\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public registerNewUser(requestParameters: RegisterNewUserRequestParams, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public registerNewUser(requestParameters: RegisterNewUserRequestParams, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public registerNewUser(requestParameters: RegisterNewUserRequestParams, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public registerNewUser(requestParameters: RegisterNewUserRequestParams, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        const RegisterUserInput = requestParameters.RegisterUserInput;\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/users/registration`,\n            RegisterUserInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './analytics.service';\nimport { AnalyticsService } from './analytics.service';\nexport * from './api.service';\nimport { ApiService } from './api.service';\nimport { ApplicationsService } from './applications.service';\nexport * from './authentication.service';\nimport { AuthenticationService } from './authentication.service';\nimport { DocumentationService } from './documentation.service';\nexport * from './portal.service';\nimport { PortalService } from './portal.service';\nexport * from './subscription.service';\nimport { SubscriptionService } from './subscription.service';\nexport * from './user.service';\nimport { UserService } from './user.service';\nexport * from './users.service';\nimport { UsersService } from './users.service';\nexport const APIS = [AnalyticsService, ApiService, ApplicationsService, AuthenticationService, DocumentationService, PortalService, SubscriptionService, UserService, UsersService];\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { PageConfiguration } from './pageConfiguration';\nimport { Metadata } from './metadata';\n\n\nexport interface Page { \n    /**\n     * Unique identifier of a page.\n     */\n    id: string;\n    /**\n     * Name of the page.\n     */\n    name: string;\n    /**\n     * Type of documentation.\n     */\n    type: Page.TypeEnum;\n    /**\n     * Order of the documentation page in its folder.\n     */\n    order: number;\n    /**\n     * Parent page. MAY be null.\n     */\n    parent?: string;\n    /**\n     * Last update date and time.\n     */\n    updated_at?: Date;\n    /**\n     * Raw content of the page.\n     */\n    content?: string;\n    /**\n     * Array of key-value about the page.\n     */\n    configuraton?: Array<PageConfiguration>;\n    /**\n     * Array of metadata about the page. This array is filled when the page has been fetched from a distant source (GitHub, GitLab, etc...).\n     */\n    metadata?: Array<Metadata>;\n}\nexport namespace Page {\n    export type TypeEnum = 'SWAGGER' | 'MARKDOWN' | 'FOLDER' | 'ROOT';\n    export const TypeEnum = {\n        SWAGGER: 'SWAGGER' as TypeEnum,\n        MARKDOWN: 'MARKDOWN' as TypeEnum,\n        FOLDER: 'FOLDER' as TypeEnum,\n        ROOT: 'ROOT' as TypeEnum\n    };\n}\n\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { Key } from './key';\n\n\nexport interface Subscription { \n    /**\n     * Unique identifier of a subscription.\n     */\n    id: string;\n    /**\n     * Subscribed API.\n     */\n    api: string;\n    /**\n     * Subscribing application.\n     */\n    application: string;\n    /**\n     * Subscribed plan.\n     */\n    plan: string;\n    /**\n     * Comment of the user when asking for a subscription.\n     */\n    request?: string;\n    /**\n     * Creation date and time of the subscription.\n     */\n    created_at?: Date;\n    /**\n     * Date and time when the subscription request was processed.\n     */\n    processed_at?: Date;\n    /**\n     * Start date and time of the subscription.\n     */\n    start_at?: Date;\n    /**\n     * Expiration date and time of the subscription.\n     */\n    end_at?: Date;\n    /**\n     * Status of the subscription.\n     */\n    status: Subscription.StatusEnum;\n    /**\n     * Only returned with *_/subscriptions/{subscriptionId}*. Need *include* query param to contain \\'keys\\'.  List of APIKeys of the subscription. \n     */\n    keys?: Array<Key>;\n}\nexport namespace Subscription {\n    export type StatusEnum = 'PENDING' | 'ACCEPTED' | 'REJECTED';\n    export const StatusEnum = {\n        PENDING: 'PENDING' as StatusEnum,\n        ACCEPTED: 'ACCEPTED' as StatusEnum,\n        REJECTED: 'REJECTED' as StatusEnum\n    };\n}\n\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Token { \n    token_type?: Token.TokenTypeEnum;\n    token?: string;\n}\nexport namespace Token {\n    export type TokenTypeEnum = 'BEARER';\n    export const TokenTypeEnum = {\n        BEARER: 'BEARER' as TokenTypeEnum\n    };\n}\n\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\nimport { AnalyticsService } from './api/analytics.service';\nimport { ApiService } from './api/api.service';\nimport { ApplicationsService } from './api/applications.service';\nimport { AuthenticationService } from './api/authentication.service';\nimport { DocumentationService } from './api/documentation.service';\nimport { PortalService } from './api/portal.service';\nimport { SubscriptionService } from './api/subscription.service';\nimport { UserService } from './api/user.service';\nimport { UsersService } from './api/users.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: [\n    AnalyticsService,\n    ApiService,\n    ApplicationsService,\n    AuthenticationService,\n    DocumentationService,\n    PortalService,\n    SubscriptionService,\n    UserService,\n    UsersService ]\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type CategoryApiQuery = 'FEATURED' | 'MINE' | 'STARRED' | 'TRENDINGS';\n\nexport const CategoryApiQuery = {\n    FEATURED: 'FEATURED' as CategoryApiQuery,\n    MINE: 'MINE' as CategoryApiQuery,\n    STARRED: 'STARRED' as CategoryApiQuery,\n    TRENDINGS: 'TRENDINGS' as CategoryApiQuery\n};\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type HttpMethod = 'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE' | 'OTHER';\n\nexport const HttpMethod = {\n    CONNECT: 'CONNECT' as HttpMethod,\n    DELETE: 'DELETE' as HttpMethod,\n    GET: 'GET' as HttpMethod,\n    HEAD: 'HEAD' as HttpMethod,\n    OPTIONS: 'OPTIONS' as HttpMethod,\n    PATCH: 'PATCH' as HttpMethod,\n    POST: 'POST' as HttpMethod,\n    PUT: 'PUT' as HttpMethod,\n    TRACE: 'TRACE' as HttpMethod,\n    OTHER: 'OTHER' as HttpMethod\n};\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * type of Identity Provider\n */\nexport type IdentityProviderType = 'GOOGLE' | 'GITHUB' | 'GRAVITEEIO_AM' | 'OIDC';\n\nexport const IdentityProviderType = {\n    GOOGLE: 'GOOGLE' as IdentityProviderType,\n    GITHUB: 'GITHUB' as IdentityProviderType,\n    GRAVITEEIOAM: 'GRAVITEEIO_AM' as IdentityProviderType,\n    OIDC: 'OIDC' as IdentityProviderType\n};\n\n"]}